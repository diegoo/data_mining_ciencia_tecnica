---
title: Data Mining en Ciencia y Técnica - TP1
author: Ariel Aguirre, Miguel Barros, José Badillo, Diego Dell'Era
output: pdf_document
---

TP1
===

Cargamos el dataset:

```{r, results='markup', warning=FALSE, message=FALSE}
glx <- read.csv("COMBO17.csv", header = T, stringsAsFactors = F)
```

# Tarea 1

str(glx) -> problema: la variable e.W420FE es de tipo 'chr'. La convertimos a numérica:

```{r, results='markup', warning=FALSE, message=FALSE}
glx$e.W420FE <- as.numeric(glx$e.W420FE)
```

# Tarea 2

```{r, results='markup', fig.width = 12, fig.height = 6, warning=FALSE, message=FALSE}
library(ggplot2)
library(gridExtra)

p1 <- qplot(BjMAG, S280MAG-BjMAG, data = glx)
p2 <- qplot(BbMAG, S280MAG-BbMAG, data = glx)
p3 <- qplot(UjMAG, S280MAG-UjMAG, data = glx)
p4 <- qplot(UbMAG, S280MAG-UbMAG, data = glx)
p5 <- qplot(VjMAG, S280MAG-VjMAG, data = glx)
p6 <- qplot(VnMAG, S280MAG-VnMAG, data = glx)
p7 <- qplot(usMAG, S280MAG-usMAG, data = glx)
p8 <- qplot(gsMAG, S280MAG-gsMAG, data = glx)
p9 <- qplot(rsMAG, S280MAG-rsMAG, data = glx)
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, p9, ncol=2, nrow=5)
```

Para separar outliers, podemos empezar por mirar el criterio de los bigotes (i.e. definir un par de barras, arriba y abajo, a 1.5 * distancia intercuartil desde la caja), y quitar los que excedan esos límites:

```{r, results='markup', fig.width = 12, fig.height = 6, warning=FALSE, message=FALSE}
limite_inferior_boxplot <- function(magnitud) { q <- quantile(magnitud, na.rm=TRUE); return (q[2] - (q[4] - q[2]) * 1.5) }
limite_superior_boxplot <- function(magnitud) { q <- quantile(magnitud, na.rm=TRUE); return (q[4] + (q[4] - q[2]) * 1.5) }

nros_ejes <- scale_y_continuous(breaks = round(seq(-30, -5, by = 0.5), 1))

b1 <-  qplot(factor(0), BjMAG,   geom = "boxplot", xlab="", data=glx) + geom_hline(yintercept=limite_inferior_boxplot(glx$BjMAG))   + geom_hline(yintercept=limite_superior_boxplot(glx$BjMAG)) + nros_ejes
b2 <-  qplot(factor(0), BbMAG,   geom = "boxplot", xlab="", data=glx) + geom_hline(yintercept=limite_inferior_boxplot(glx$BbMAG))   + geom_hline(yintercept=limite_superior_boxplot(glx$BbMAG)) + nros_ejes
b3 <-  qplot(factor(0), UjMAG,   geom = "boxplot", xlab="", data=glx) + geom_hline(yintercept=limite_inferior_boxplot(glx$UjMAG))   + geom_hline(yintercept=limite_superior_boxplot(glx$UjMAG)) + nros_ejes
b4 <-  qplot(factor(0), UbMAG,   geom = "boxplot", xlab="", data=glx) + geom_hline(yintercept=limite_inferior_boxplot(glx$UbMAG))   + geom_hline(yintercept=limite_superior_boxplot(glx$UbMAG)) + nros_ejes
b5 <-  qplot(factor(0), VjMAG,   geom = "boxplot", xlab="", data=glx) + geom_hline(yintercept=limite_inferior_boxplot(glx$VjMAG))   + geom_hline(yintercept=limite_superior_boxplot(glx$VjMAG)) + nros_ejes
b6 <-  qplot(factor(0), VnMAG,   geom = "boxplot", xlab="", data=glx) + geom_hline(yintercept=limite_inferior_boxplot(glx$VnMAG))   + geom_hline(yintercept=limite_superior_boxplot(glx$VnMAG)) + nros_ejes
b7 <-  qplot(factor(0), usMAG,   geom = "boxplot", xlab="", data=glx) + geom_hline(yintercept=limite_inferior_boxplot(glx$usMAG))   + geom_hline(yintercept=limite_superior_boxplot(glx$usMAG)) + nros_ejes
b8 <-  qplot(factor(0), gsMAG,   geom = "boxplot", xlab="", data=glx) + geom_hline(yintercept=limite_inferior_boxplot(glx$gsMAG))   + geom_hline(yintercept=limite_superior_boxplot(glx$gsMAG)) + nros_ejes
b9 <-  qplot(factor(0), rsMAG,   geom = "boxplot", xlab="", data=glx) + geom_hline(yintercept=limite_inferior_boxplot(glx$rsMAG))   + geom_hline(yintercept=limite_superior_boxplot(glx$rsMAG)) + nros_ejes
b10 <- qplot(factor(0), ApDRmag, geom = "boxplot", xlab="", data=glx) + geom_hline(yintercept=limite_inferior_boxplot(glx$ApDRmag)) + geom_hline(yintercept=limite_superior_boxplot(glx$ApDRmag)) + scale_y_continuous(breaks = round(seq(min(glx$ApDRmag), max(glx$ApDRmag), by = 0.5), 1))
grid.arrange(b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, ncol=4, nrow=3)
```

Pero quitaríamos demasiados puntos con ese criterio... Mejor quitamos sólo los que son claramente outliers, en las variables *ApRDmag* y de *BjMAG*:

```{r, results='markup', warning=FALSE, message=FALSE}
# antes de quitar outliers
dim(glx)

glx <- subset(glx, ApDRmag > -3.2)
glx <- subset(glx, BjMAG < -7.0)

# después
dim(glx)
```

# Tarea 3

Miramos si alguna variable (i.e., columna) tiene valores faltante:

```{r, results='markup', warning=FALSE, message=FALSE}
apply(glx, 2, function(x) anyNA(x))
```

De las variables de interés, hay 2 con datos faltantes: *VnMAG*, *S280MAG*

```{r, results='markup', warning=FALSE, message=FALSE}
faltantes_VnMAG <- which(is.na(glx$VnMAG))
faltantes_S280MAG <- which(is.na(glx$S280MAG))
faltantes_VnMAG
faltantes_S280MAG
```

También hay valores faltantes en las variables asociadas de error, en los mismos registros:

```{r, results='markup', warning=FALSE, message=FALSE}
faltantes_e.VbMAG <- which(is.na(glx$e.VbMAG))
faltantes_e.280MA <- which(is.na(glx$e.S280MA))
faltantes_e.VbMAG
faltantes_e.280MA
```

Son 24 registros en total. Los borramos:

```{r, results='markup', warning=FALSE, message=FALSE}
glx_sin_faltantes <- glx[complete.cases(glx[,26:29]),]
dim(glx)[1] - 24 == dim(glx_sin_faltantes)[1]
```

# Tarea 4

```{r, results='markup', warning=FALSE, message=FALSE}
espectrales <- c(10,12,14,16,18,20,22,24,26,28)
variables_de_magnitud_absoluta_en_reposo <- glx_sin_faltantes[, espectrales]
head(variables_de_magnitud_absoluta_en_reposo)
```

```{r, results='markup', fig.width = 9, fig.height = 9, warning=FALSE, message=FALSE}
library(corrplot)
correlaciones <- cor(variables_de_magnitud_absoluta_en_reposo)
# corrplot(correlaciones, method="circle", type="lower")
corrplot.mixed(correlaciones, lower="circle", upper="number")
```

A cada magnitud le restamos la magnitud a 280 nm:

```{r, results='markup', warning=FALSE, message=FALSE}
variables_de_magnitud_absoluta_en_reposo_normalizadas <- sweep(variables_de_magnitud_absoluta_en_reposo[,1:9], 1, variables_de_magnitud_absoluta_en_reposo$S280MAG, `-`)
head(variables_de_magnitud_absoluta_en_reposo_normalizadas)
```

```{r, results='markup', fig.width = 9, fig.height = 9, warning=FALSE, message=FALSE}
correlaciones_de_normalizadas <- cor(variables_de_magnitud_absoluta_en_reposo_normalizadas)
# corrplot(correlaciones_de_normalizadas, method="circle", type="lower")
corrplot.mixed(correlaciones_de_normalizadas, lower="circle", upper="number")
```
