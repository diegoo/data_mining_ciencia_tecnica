<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>TP1 - parte 2</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>TP1 - parte 2</h1>

<h2>Tarea 1</h2>

<p>Aplicamos los pasos de la parte 1.</p>

<pre><code class="r">glx_0 &lt;- read.csv(&quot;dataset.procesado.parte.1.csv&quot;, header = T, stringsAsFactors = F)
head(glx_0, 1)
</code></pre>

<pre><code>##   nr   rmag            apdrmag  ujmag  bjmag  vjmag  usmag gsmag  rsmag
## 1  6 24.995 0.9350000000000001 -17.67 -17.54 -17.76 -17.83 -17.6 -17.97
##    ubmag  bbmag  vbmag s280mag
## 1 -17.76 -17.53 -17.76  -18.22
</code></pre>

<p>Analizamos agrupamientos usando k-medias. Pasos:</p>

<ul>
<li>Quitamos variables correlacionadas</li>
</ul>

<p>Las variables que obviamente tienen índice de correlación 1 (normalizadas restando <code>s280</code>), según los resultados de la parte 1, son:</p>

<pre><code class="r"># (ujmag, usmag, ubmag)
# (bjmag, bbmag)
# (vjmag, rsmag, vnmag)
</code></pre>

<p>Nos quedamos con 1 que represente a cada grupo:</p>

<pre><code class="r">glx_1 &lt;- glx_0[,c(1:6)]
</code></pre>

<ul>
<li>Estandarizamos variables</li>
</ul>

<pre><code class="r"># sólo estandarizamos variables con mediciones (sin la primera columna, porque es el número de galaxia)
glx_2 &lt;- scale(glx_1[,c(2:6)])
head(glx_2, 1)
</code></pre>

<pre><code>##                    rmag           apdrmag              ujmag
## [1,] 0.7481409363139495 2.530149066971338 0.1184136486227584
##                   bjmag              vjmag
## [1,] 0.1237063466556295 0.1841887849416674
</code></pre>

<ul>
<li><p>Determinamos el <code>k</code> óptimo para K-means:</p></li>
<li><p>Gráficamente</p></li>
</ul>

<p>Podemos ver el <code>k</code> óptimo como el punto de corte en que deja de disminuir marcadamente la suma de cuadrados dentro del cluster. En otras palabras, el punto en que la cohesión de los clusters deja de aumentar.</p>

<pre><code class="r">wssplot &lt;- function(data, nc=15, seed=1234){wss &lt;- (nrow(data)-1)*sum(apply(data,2,var))
               for (i in 2:nc){
                    set.seed(seed)
                    wss[i] &lt;- sum(kmeans(data, centers=i)$withinss)}
                plot(1:nc, wss, type=&quot;b&quot;, xlab=&quot;Número de clusters&quot;,
                     ylab=&quot;Suma de cuadrados dentro del cluster&quot;)}

wssplot(glx_2)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-7"/> </p>

<p>El gráfico sugiere usar <code>k</code> = 3.</p>

<ul>
<li>Analíticamente</li>
</ul>

<p>Calculamos una matrix de distancias:</p>

<pre><code class="r">library(cluster)
glx_2_dist &lt;- dist(glx_2)
</code></pre>

<p>Usamos la matriz de distancias con <code>kmeans</code>:</p>

<pre><code class="r"># una función que, dado un k, clusteriza por kmeans -&gt; calcula silhouette -&gt; devuelve ancho promedio
silhoutte_kmeans &lt;- function(k) {
  c &lt;- kmeans(glx_2, centers = k)$cluster
  s &lt;- silhouette(c, glx_2_dist)
  return(summary(s)$avg.width)
}

# aplicamos la función para valores de k entre 2 y 10
indice_por_k_kmeans &lt;- sapply(c(2:10), silhoutte_kmeans)
which.max(indice_por_k_kmeans)
</code></pre>

<pre><code>## [1] 2
</code></pre>

<p>El <code>k</code> que maximiza el ancho promedio de silhouette para todos los clusters creados via K-means es el segundo =&gt; <code>k</code> = 3.</p>

<h2>Tarea 1 (optativa): Comparar métodos</h2>

<p>Ahora usamos PAM en lugar de K-means:</p>

<pre><code class="r"># una función que, dado un k, clusteriza por PAM -&gt; calcula silhouette -&gt; devuelve ancho promedio
silhoutte_pam &lt;- function(k) {
  c &lt;- pam(glx_2_dist, k=k, diss=T)
  s &lt;- silhouette(c)
  return(summary(s)$avg.width)
}

# aplicamos la función para valores de k entre 2 y 10
indice_por_k_pam &lt;- sapply(c(2:10), silhoutte_pam)
which.max(indice_por_k_pam)
</code></pre>

<pre><code>## [1] 1
</code></pre>

<p>El <code>k</code> que maximiza el ancho promedio de silhouette para todos los clusters creados via PAM es el primero =&gt; <code>k</code> = 2.</p>

<p>También podemos probar otra biblioteca para clusterizar maximizando el índice de Silhouette:</p>

<pre><code class="r">library(NbClust)
set.seed(1234)
nc &lt;- NbClust(glx_2, min.nc = 2, max.nc = 10, method = &quot;kmeans&quot;, index = &quot;silhouette&quot;)
nc$Best.nc
</code></pre>

<pre><code>## Number_clusters     Value_Index 
##          2.0000          0.4659
</code></pre>

<p>Este método también sugiere usar <code>k</code> = 2.</p>

<h2>Tarea 2</h2>

<p>Cargamos el dataset entero (partimos de un .csv que fue creado a partir del dataset original descargado del website y parseado según las instrucciones para cada campo):</p>

<pre><code class="r">glx &lt;- read.csv(&quot;dmcyt_tp2.csv&quot;, header = T, stringsAsFactors = F, sep = &#39;|&#39;)
glx$mc_class &lt;- as.factor(glx$mc_class)

# evitemos que R trunque decimales
options(digits=16)
</code></pre>

<p>Quitamos outliers:</p>

<pre><code class="r">glx_sin_outliers &lt;- subset(glx, apd_rmag &gt; -3.2)
glx_sin_outliers &lt;- subset(glx_sin_outliers, bjmag &lt; -7.0)
glx_sin_outliers &lt;- subset(glx_sin_outliers, ujmag &lt; -10.0)
glx_sin_outliers &lt;- subset(glx_sin_outliers, vjmag &lt; -10.0)
glx_sin_outliers &lt;- subset(glx_sin_outliers, usmag &lt; -10.0)
glx_sin_outliers &lt;- subset(glx_sin_outliers, gsmag &lt; -9.0)
glx_sin_outliers &lt;- subset(glx_sin_outliers, rsmag &lt; -9.0)
# glx_sin_outliers &lt;- subset(glx_sin_outliers, bbmag &lt; -9.0) # todos los valores en 0?
# glx_sin_outliers &lt;- subset(glx_sin_outliers, ubmag &lt; -10.0) # todos los valores en 0?
# glx_sin_outliers &lt;- subset(glx_sin_outliers, vbmag &lt; -10.0) # todos los valores en 0? (antes era vnmag)

nrow(glx) - nrow(glx_sin_outliers)
</code></pre>

<pre><code>## [1] 8181
</code></pre>

<p>Buscamos datos faltantes:</p>

<pre><code class="r">glx_sin_faltantes &lt;- glx_sin_outliers[complete.cases(glx_sin_outliers),]
nrow(glx_sin_outliers) - nrow(glx_sin_faltantes)
</code></pre>

<pre><code>## [1] 720
</code></pre>

<p>Dimensiones del dataset final:</p>

<pre><code class="r">dim(glx_sin_faltantes)
</code></pre>

<pre><code>## [1] 54600    26
</code></pre>

<h2>Tarea 3</h2>

<p>Extraemos las variables que tienen mediciones para poder encontrar clusters:</p>

<pre><code class="r">glx_tarea3.0 &lt;- glx_sin_faltantes[,c(11,13,17,18,19)]
</code></pre>

<p>Ahora calculamos distancias para correr PAM y después Silhouette:</p>

<pre><code class="r">glx_tarea3.1 &lt;- dist(scale(glx_tarea3.0))
</code></pre>

<pre><code>## Error in dist(scale(glx_tarea3.0)): negative length vectors are not allowed
</code></pre>

<p>Pinchó. ¿Por qué?</p>

<p>Calcular la matriz de distancias implica que, por cada elemento de la matriz, hay que calcular la distancia a todos los demás elementos. Es decir, es un procedimiento cuadrático: si la matriz tiene <code>n</code> elementos, hay que almacenar <code>n x n</code> distancias.</p>

<p>Se puede deducir, para el caso de la implementación de R, dónde está el problema de alocación de memoria:</p>

<pre><code class="r"># tomamos las primeras 16000 filas
glx_muestra_16k &lt;- glx_sin_faltantes[c(1:16000), c(11,13,17,18,19)]

# intentamos calcular la matriz, y la imprimimos para forzarlo a que nos devuelve un mensaje de error
dist(scale(glx_muestra_16k))
</code></pre>

<pre><code>## Error: cannot allocate vector of size 976.5 Mb
</code></pre>

<p>Por el mensaje de error, vemos que no puede alocar espacio (0.975 Gb). Entonces podemos despejar la cantidad de bytes que usa para guardar distancias:</p>

<pre><code class="r">0.975 * (1024)^3 / (16000^2)
</code></pre>

<pre><code>## [1] 4.0894464
</code></pre>

<p>Son 4 bytes. Usando apenas 4 bytes para almacenar distancias, el cálculo para una matriz de tamaño modesto se vuelve demasiado costoso, rápidamente.</p>

<p>Podemos probar de nuevo restringiendo el tamaño del dataset (y limpiando un poco con gc()).</p>

<pre><code>##             used   (Mb) gc trigger   (Mb)  max used   (Mb)
## Ncells    377229   10.1     750400   20.1    750400   20.1
## Vcells 188798765 1440.5  394833792 3012.4 368817866 2813.9
</code></pre>

<p>Tomamos una muestra de 10000 objetos (en la compu donde corre esto, si tomamos más de 15000 pincha). Agrupamos con K-means buscando el <code>k</code> óptimo:</p>

<pre><code class="r">filas_muestra &lt;- sample(nrow(glx_sin_faltantes), size = 10000)
glx_muestra_10k &lt;- glx_sin_faltantes[filas_muestra,]
glx_muestra_10k_mediciones &lt;- glx_muestra_10k[,c(11,13,17,18,19)]
head(glx_muestra_10k_mediciones, 1)
</code></pre>

<pre><code>##         rmag ap_rmag  ujmag  bjmag  vjmag
## 31278 24.193  24.278 -19.02 -18.93 -19.11
</code></pre>

<pre><code class="r">glx_muestra_10k_dist &lt;- dist(scale(glx_muestra_10k_mediciones))

silhoutte_kmeans &lt;- function(k) {
  c &lt;- kmeans(glx_muestra_10k_mediciones, centers = k)$cluster
  s &lt;- silhouette(c, glx_muestra_10k_dist)
  return(summary(s)$avg.width)
}

# aplicamos la función para valores de k entre 2 y 10
indice_por_k_kmeans &lt;- sapply(c(2:20), silhoutte_kmeans)
which.max(indice_por_k_kmeans)
</code></pre>

<pre><code>## [1] 2
</code></pre>

<p>Ahora obtenemos el segundo k, o sea <code>k</code> = 3.</p>

</body>

</html>
